<?php

declare(strict_types=1);

namespace PaneeDesign\DatabaseSwiftMailerBundle\Repository;

use DateTime;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\ORM\OptimisticLockException;
use Doctrine\ORM\ORMException;
use Doctrine\ORM\Query;
use Doctrine\Persistence\ManagerRegistry;
use PaneeDesign\DatabaseSwiftMailerBundle\Entity\Email;
use Swift_SwiftException;

/**
 * EmailRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EmailRepository extends ServiceEntityRepository implements EmailRepositoryInterface
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Email::class);
    }

    /**
     * @param Email $email
     * @param bool|null $autoFlush
     *
     * @throws ORMException
     * @throws OptimisticLockException
     */
    public function addEmail(Email $email, ?bool $autoFlush = true): void
    {
        $em = $this->getEntityManager();
        $email->setStatus(Email::STATUS_READY);
        $email->setCreatedAt(new DateTime());

        $scheduledDbChanges = 0;
        $scheduledDbChanges += \count($em->getUnitOfWork()->getScheduledEntityInsertions());
        $scheduledDbChanges += \count($em->getUnitOfWork()->getScheduledEntityUpdates());
        $scheduledDbChanges += \count($em->getUnitOfWork()->getScheduledEntityDeletions());
        $scheduledDbChanges += \count($em->getUnitOfWork()->getScheduledCollectionUpdates());
        $scheduledDbChanges += \count($em->getUnitOfWork()->getScheduledCollectionUpdates());

        $em->persist($email);

        // Flush only if there are not other db changes
        if (0 === $scheduledDbChanges) {
            $em->flush();
        }
    }

    /**
     * @param null $limit
     * @param null $offset
     *
     * @return Query
     */
    public function getAllEmails($limit = null, $offset = null)
    {
        $qb = $this->createQueryBuilder('e');

        $qb
            ->addOrderBy('e.createdAt', 'DESC')
            ->setFirstResult($offset)
            ->setMaxResults($limit);

        return $qb->getQuery();
    }

    /**
     * @param int $limit
     * @param int $maxRetries
     *
     * @throws ORMException
     * @throws OptimisticLockException
     *
     * @return Email[]
     */
    public function getEmailQueue($limit = 100, $maxRetries = 10)
    {
        $qb = $this->createQueryBuilder('e');

        $qb->where($qb->expr()->in('e.status', ':status'));
        $qb->andWhere($qb->expr()->lt('e.retries', ':retries'));
        $qb->setParameters([
            'status' => [Email::STATUS_READY, Email::STATUS_FAILED],
            'retries' => $maxRetries,
        ]);

        $qb->addOrderBy('e.retries', 'ASC');
        $qb->addOrderBy('e.createdAt', 'ASC');

        if (false === empty($limit)) {
            $qb->setMaxResults($limit);
        }

        $em = $this->getEntityManager();

        /** @var Email[] $emails */
        $emails = $qb->getQuery()->getResult();

        if (\count($emails) > 0) {
            foreach ($emails as $email) {
                $email->setStatus(Email::STATUS_PROCESSING);

                $em->persist($email);
            }

            $em->flush();
        }

        return $emails;
    }

    /**
     * @param Email                $email
     * @param Swift_SwiftException $ex
     *
     * @throws ORMException
     * @throws OptimisticLockException
     */
    public function markFailedSending(Email $email, Swift_SwiftException $ex): void
    {
        $email->setErrorMessage($ex->getMessage());
        $email->setStatus(Email::STATUS_FAILED);
        $email->setRetries((int) ($email->getRetries()) + 1);
        $email->setUpdatedAt(new DateTime());

        $em = $this->getEntityManager();
        $em->persist($email);
        $em->flush();
    }

    /**
     * @param Email $email
     *
     * @throws ORMException
     * @throws OptimisticLockException
     */
    public function markCompleteSending(Email $email): void
    {
        $email->setStatus(Email::STATUS_COMPLETE);
        $email->setSentAt(new DateTime());
        $email->setErrorMessage(null);
        $email->setUpdatedAt(new DateTime());

        $em = $this->getEntityManager();
        $em->persist($email);
        $em->flush();
    }

    /**
     * @param Email $email
     *
     * @throws ORMException
     * @throws OptimisticLockException
     */
    public function deleteSentMessages(Email $email): void
    {
        $em = $this->getEntityManager();
        $em->remove($email);
        $em->flush();
    }
}
